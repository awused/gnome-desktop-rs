// This file was generated by gir (https://github.com/gtk-rs/gir)
// from
// from gir-files (https://github.com/gtk-rs/gir-files.git)
// DO NOT EDIT

use crate::DesktopThumbnailSize;
use glib::object::IsA;
use glib::translate::*;
use std::ptr;

/// Returns whether the thumbnail has the correct uri and mtime embedded in the
/// png options. This function is threadsafe and does no blocking I/O.
/// ## `pixbuf`
/// an loaded thumbnail #GdkPixbuf
/// ## `uri`
/// a uri
/// ## `mtime`
/// the mtime
///
/// # Returns
///
/// TRUE if the thumbnail has the right @uri and @mtime
#[doc(alias = "gnome_desktop_thumbnail_is_valid")]
pub fn desktop_thumbnail_is_valid(
    pixbuf: &gdk_pixbuf::Pixbuf,
    uri: &str,
    mtime: libc::c_long,
) -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gnome_desktop_thumbnail_is_valid(
            pixbuf.to_glib_none().0,
            uri.to_glib_none().0,
            mtime,
        ))
    }
}

/// Returns the filename that a thumbnail of size @size for @uri would have.
/// This function is threadsafe and does no blocking I/O.
/// ## `uri`
/// an uri
/// ## `size`
/// a thumbnail size
///
/// # Returns
///
/// an absolute filename
#[doc(alias = "gnome_desktop_thumbnail_path_for_uri")]
pub fn desktop_thumbnail_path_for_uri(
    uri: &str,
    size: DesktopThumbnailSize,
) -> Option<glib::GString> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_full(ffi::gnome_desktop_thumbnail_path_for_uri(
            uri.to_glib_none().0,
            size.into_glib(),
        ))
    }
}

/// Gets all locales.
///
/// # Returns
///
///
///   a newly allocated [`None`]-terminated string array containing the
///   all locales. Free with g_strfreev().
#[doc(alias = "gnome_get_all_locales")]
#[doc(alias = "get_all_locales")]
pub fn all_locales() -> Vec<glib::GString> {
    assert_initialized_main_thread!();
    unsafe { FromGlibPtrContainer::from_glib_full(ffi::gnome_get_all_locales()) }
}

/// Gets the country name for @code. If @translation is provided the
/// returned string is translated accordingly.
/// ## `code`
/// an ISO 3166 code string
/// ## `translation`
/// a locale string
///
/// # Returns
///
/// the country name. Caller takes
/// ownership.
#[doc(alias = "gnome_get_country_from_code")]
#[doc(alias = "get_country_from_code")]
pub fn country_from_code(code: &str, translation: Option<&str>) -> Option<glib::GString> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_full(ffi::gnome_get_country_from_code(
            code.to_glib_none().0,
            translation.to_glib_none().0,
        ))
    }
}

/// Gets the country description for @locale. If @translation is
/// provided the returned string is translated accordingly.
/// ## `locale`
/// a locale string
/// ## `translation`
/// a locale string
///
/// # Returns
///
/// the country description. Caller
/// takes ownership.
#[doc(alias = "gnome_get_country_from_locale")]
#[doc(alias = "get_country_from_locale")]
pub fn country_from_locale(locale: &str, translation: Option<&str>) -> Option<glib::GString> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_full(ffi::gnome_get_country_from_locale(
            locale.to_glib_none().0,
            translation.to_glib_none().0,
        ))
    }
}

/// Gets the default input source's type and identifier for a given
/// locale.
/// ## `locale`
/// a locale string
///
/// # Returns
///
/// [`true`] if a input source exists or [`false`] otherwise.
///
/// ## `type_`
/// location to store the input source
/// type
///
/// ## `id`
/// location to store the input source
/// identifier
#[doc(alias = "gnome_get_input_source_from_locale")]
#[doc(alias = "get_input_source_from_locale")]
pub fn input_source_from_locale(locale: &str) -> Option<(glib::GString, glib::GString)> {
    assert_initialized_main_thread!();
    unsafe {
        let mut type_ = ptr::null();
        let mut id = ptr::null();
        let ret = from_glib(ffi::gnome_get_input_source_from_locale(
            locale.to_glib_none().0,
            &mut type_,
            &mut id,
        ));
        if ret {
            Some((from_glib_none(type_), from_glib_none(id)))
        } else {
            None
        }
    }
}

/// Gets the language name for @code. If @translation is provided the
/// returned string is translated accordingly.
/// ## `code`
/// an ISO 639 code string
/// ## `translation`
/// a locale string
///
/// # Returns
///
/// the language name. Caller takes
/// ownership.
#[doc(alias = "gnome_get_language_from_code")]
#[doc(alias = "get_language_from_code")]
pub fn language_from_code(code: &str, translation: Option<&str>) -> Option<glib::GString> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_full(ffi::gnome_get_language_from_code(
            code.to_glib_none().0,
            translation.to_glib_none().0,
        ))
    }
}

/// Gets the language description for @locale. If @translation is
/// provided the returned string is translated accordingly.
/// ## `locale`
/// a locale string
/// ## `translation`
/// a locale string
///
/// # Returns
///
/// the language description. Caller
/// takes ownership.
#[doc(alias = "gnome_get_language_from_locale")]
#[doc(alias = "get_language_from_locale")]
pub fn language_from_locale(locale: &str, translation: Option<&str>) -> Option<glib::GString> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_full(ffi::gnome_get_language_from_locale(
            locale.to_glib_none().0,
            translation.to_glib_none().0,
        ))
    }
}

/// Returns an integer with the major version of GNOME. Useful for
/// dynamic languages like Javascript or Python (static languages like
/// C should use `GNOME_DESKTOP_PLATFORM_VERSION`). If this
/// function doesn't exist, it can be presumed that the GNOME platform
/// version is 42 or previous.
///
/// # Returns
///
/// an integer with the major version of GNOME.
#[cfg(any(feature = "v43", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v43")))]
#[doc(alias = "gnome_get_platform_version")]
#[doc(alias = "get_platform_version")]
pub fn platform_version() -> i32 {
    assert_initialized_main_thread!();
    unsafe { ffi::gnome_get_platform_version() }
}

/// Gets a translation of the raw @modifier string. If @translation
/// is provided the returned string is translated accordingly.
/// ## `modifier`
/// the modifier part of a locale name
/// ## `translation`
/// a locale string
///
/// # Returns
///
/// the translated modifier string.
/// Caller takes ownership.
#[doc(alias = "gnome_get_translated_modifier")]
#[doc(alias = "get_translated_modifier")]
pub fn translated_modifier(modifier: &str, translation: Option<&str>) -> Option<glib::GString> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_full(ffi::gnome_get_translated_modifier(
            modifier.to_glib_none().0,
            translation.to_glib_none().0,
        ))
    }
}

/// Returns [`true`] if there are translations for language @code.
/// ## `code`
/// an ISO 639 code string
///
/// # Returns
///
/// [`true`] if there are translations for language @code.
#[doc(alias = "gnome_language_has_translations")]
pub fn language_has_translations(code: &str) -> bool {
    assert_initialized_main_thread!();
    unsafe { from_glib(ffi::gnome_language_has_translations(code.to_glib_none().0)) }
}

/// Gets the normalized locale string in the form
/// [language[_country][.codeset][@modifier]] for @name.
/// ## `locale`
/// a locale string
///
/// # Returns
///
/// normalized locale string. Caller
/// takes ownership.
#[doc(alias = "gnome_normalize_locale")]
pub fn normalize_locale(locale: &str) -> Option<glib::GString> {
    assert_initialized_main_thread!();
    unsafe { from_glib_full(ffi::gnome_normalize_locale(locale.to_glib_none().0)) }
}

/// Extracts the various components of a locale string in XPG format.
/// ([language[_country][.codeset][@modifier]]). See
/// http://en.wikipedia.org/wiki/Locale.
/// ## `locale`
/// a locale string
///
/// # Returns
///
/// [`true`] if parsing was successful.
///
/// ## `language_codep`
/// location to
/// store the language code, or [`None`]
///
/// ## `country_codep`
/// location to
/// store the country code, or [`None`]
///
/// ## `codesetp`
/// location to
/// store the codeset, or [`None`]
///
/// ## `modifierp`
/// location to
/// store the modifier, or [`None`]
#[doc(alias = "gnome_parse_locale")]
pub fn parse_locale(
    locale: &str,
) -> Option<(
    glib::GString,
    Option<glib::GString>,
    Option<glib::GString>,
    Option<glib::GString>,
)> {
    assert_initialized_main_thread!();
    unsafe {
        let mut language_codep = ptr::null_mut();
        let mut country_codep = ptr::null_mut();
        let mut codesetp = ptr::null_mut();
        let mut modifierp = ptr::null_mut();
        let ret = from_glib(ffi::gnome_parse_locale(
            locale.to_glib_none().0,
            &mut language_codep,
            &mut country_codep,
            &mut codesetp,
            &mut modifierp,
        ));
        if ret {
            Some((
                from_glib_full(language_codep),
                from_glib_full(country_codep),
                from_glib_full(codesetp),
                from_glib_full(modifierp),
            ))
        } else {
            None
        }
    }
}

//#[doc(alias = "gnome_start_systemd_scope")]
//pub fn start_systemd_scope<P: FnOnce(Result<(), glib::Error>) + 'static>(name: &str, pid: i32, description: Option<&str>, connection: /*Ignored*/Option<&gio::DBusConnection>, cancellable: Option<&impl IsA<gio::Cancellable>>, callback: P) {
//    unsafe { TODO: call ffi:gnome_start_systemd_scope() }
//}

//
//pub fn start_systemd_scope_future(name: &str, pid: i32, description: Option<&str>, connection: /*Ignored*/Option<&gio::DBusConnection>) -> Pin<Box_<dyn std::future::Future<Output = Result<(), glib::Error>> + 'static>> {

//skip_assert_initialized!();
//let name = String::from(name);
//let description = description.map(ToOwned::to_owned);
//let connection = connection.map(ToOwned::to_owned);
//Box_::pin(gio::GioFuture::new(&(), move |_obj, cancellable, send| {
//    start_systemd_scope(
//        &name,
//        pid,
//        description.as_ref().map(::std::borrow::Borrow::borrow),
//        connection.as_ref().map(::std::borrow::Borrow::borrow),
//        Some(cancellable),
//        move |res| {
//            send.resolve(res);
//        },
//    );
//}))
//}
